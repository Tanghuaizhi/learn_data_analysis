---
output: html_document
editor_options: 
  chunk_output_type: console
---
Lesson 6
========================================================

### Welcome
Notes:

***

### Scatterplot Review

Let's start by examining two variables in the data set.
The scatterplot is a powerful tool to help you understand
the relationship between two continuous variables.

We can quickly see if the relationship is linear or not.
In this case, we can use a variety of diamond
characteristics to help us figure out whether
the price advertised for any given diamond is 
reasonable or a rip-off.

Let's consider the price of a diamond and it's carat weight.
Create a scatterplot of price (y) vs carat weight (x).

Limit the x-axis and y-axis to omit the top 1% of values.

提示：在 xlim 和 ylim 中使用 quantile() 函数，以忽略每个变量前 1% 的值。

```{r Scatterplot Review}
getwd()
setwd("D:/learn_data_analysis/R basic/lesson6")

library(ggplot2)
data(diamonds)

ggplot(data = diamonds,aes(x = carat, y = price)) +
  geom_point() +
  coord_trans(limx = c(quantile(diamonds$carat, 0.01), 5.01), limy = c(quantile(diamonds$price, 0.01), 18823))


# answer
ggplot(data = diamonds,aes(x = carat, y = price)) +
  coord_trans(limx = c(0, quantile(diamonds$carat, 0.99)), 
              limy = c(0, quantile(diamonds$price, 0.99))) +
  geom_point(fill = I('#F79420'), color = I('black'), shape = 21)


```

***

### Price and Carat Relationship
Response:
what do you notice about the relationship between price and carat?
价格随重量上升而上升。
但并不是线性关系。
同时重量越大，价格范围越大。

可增加辅助线更直观表示。
```{r}
ggplot(data = diamonds,aes(x = carat, y = price)) +
  coord_trans(limx = c(0, quantile(diamonds$carat, 0.99)), 
              limy = c(0, quantile(diamonds$price, 0.99))) +
  geom_point(fill = I('#F79420'), color = I('black'), shape = 21) +
  stat_smooth(method = 'lm')

```


***

### Frances Gerety
Notes:

#### A diamonds is Forever


***

### The Rise of Diamonds
Notes:

***

### ggpairs Function
Notes:
记住，首先可以使用GG pairs函数对主要变量之间进行绘图。
注意，该图绘制十分耗时，如果变量超过10个，先将列进行子集划分。




ggpairs 函数的“params”参数用于改变在图形矩阵中绘制的点的形状，以便更容易查看这些点。GGally 1.0 改变了这些绘图参数的语法，使它们不再是 params 参数的一部分，而是让用户能如下所示指定这些参数：

ggpairs(diamond_samp, 
  lower = list(continuous = wrap("points", shape = I('.'))), 
  upper = list(combo = wrap("box", outlier.shape = I('.'))))

You can click on the packages tab in RStudio to determine which packages have been installed.

In this video, Solomon works with the plyr package. We worked with the dplyr package to manipulate data frames and to create new ones throughout the course. dplyr is the latest version of plyr that is specifically for working with data frames.

Similarly, we worked with the reshape2 package, which is the newest version of the reshape package.


注意：
ggpairs output When you duplicate the plot matrix on your local machine, you may want to add a axisLabels = 'internal' argument to your ggpairs function call to have the variable names on the diagonal of the matrix rather than on the outside.

```{r ggpairs Function}
# install these if necessary
#install.packages('GGally')
#install.packages('scales')
#install.packages('memisc')
#install.packages('lattice')
#install.packages('MASS')
#install.packages('car')
#install.packages('reshape')
#install.packages('plyr')

# load the ggplot graphics package and the others
library(ggplot2)
library(GGally)
library(scales)
library(memisc)

# sample 10,000 diamonds from the data set
set.seed(20022012)
diamond_samp <- diamonds[sample(1:length(diamonds$price), 10000), ]
#ggpairs(diamond_samp, params = c(shape = I('.'), outlier.shape = I('.')))
ggpairs(diamond_samp, 
  lower = list(continuous = wrap("points", shape = I('.'))), 
  upper = list(combo = wrap("box", outlier.shape = I('.'))))

```

What are some things you notice in the ggpairs output?
Response:
价格和重量呈指数相关，和x、y、z高度相关，和depth、table的相关性并不明显。

***

### The Demand of Diamonds
Notes:



Create two histograms of the price variable
and place them side by side on one output image.

The first plot should be a histogram of price
and the second plot should transform
the price variable using log10.

Set appropriate bin widths for each plot.
ggtitle() will add a title to each histogram.

```{r The Demand of Diamonds}
library(gridExtra)

plot1 <- ggplot(data = diamonds, aes(x = price)) + 
  geom_histogram() + 
  ggtitle('Price')

plot2 <- ggplot(data = diamonds, aes(x = price)) + 
  geom_histogram() +
  scale_x_log10() +
  ggtitle('Price (log10)')

grid.arrange(plot1, plot2)



#answer
plot1 <- qplot(data = diamonds, x = price, binwidth = 100, fill = I('#099DD9')) + 
  ggtitle('Price')

plot2 <- qplot(data = diamonds, x = price, binwidth = 0.01, fill = I('#F79420')) +
  scale_x_log10() +
  ggtitle('Price (log10)')

grid.arrange(plot1, plot2, ncol =2)


```

***



### Connecting Demand and Price Distributions
Notes:
上图表明，价格在1000元、7000元附近形成两个顶点，说明这两个价格的市场需求最旺盛。
符合正态分布，双峰型。

表明有富人、穷人不同的买家。
***

### Scatterplot Transformation

```{r Scatterplot Transformation}
qplot(data = diamonds, x = carat, y = price) +
  scale_y_continuous(trans = log10_trans()) +
  ggtitle('Price (log10) by Carat')
```


### Create a new function to transform the carat variable
构建了一个转换函数
```{r cuberoot transformation}
cuberoot_trans = function() trans_new('cuberoot', transform = function(x) x^(1/3),
                                      inverse = function(x) x^3)
```

#### Use the cuberoot_trans function
```{r Use cuberoot_trans}
ggplot(aes(carat, price), data = diamonds) + 
  geom_point() + 
  scale_x_continuous(trans = cuberoot_trans(), limits = c(0.2, 3),
                     breaks = c(0.2, 0.5, 1, 2, 3)) + 
  scale_y_continuous(trans = log10_trans(), limits = c(350, 15000),
                     breaks = c(350, 1000, 5000, 10000, 15000)) +
  ggtitle('Price (log10) by Cube-Root of Carat')
```

***

### Overplotting Revisited

```{r Sort and Head Tables}
head(sort(table(diamonds$carat), decreasing = T))
head(sort(table(diamonds$price), decreasing = T))
```


Add a layer to adjust the features of the
scatterplot. Set the transparency to one half,
the size to three-fourths, and jitter the points.

```{r Overplotting Revisited}
ggplot(aes(carat, price), data = diamonds) + 
  geom_jitter(alpha = 1/2, size = 0.75) + 
  scale_x_continuous(trans = cuberoot_trans(), limits = c(0.2, 3),
                     breaks = c(0.2, 0.5, 1, 2, 3)) + 
  scale_y_continuous(trans = log10_trans(), limits = c(350, 15000),
                     breaks = c(350, 1000, 5000, 10000, 15000)) +
  ggtitle('Price (log10) by Cube-Root of Carat')
```

***

### Other Qualitative Factors
Notes:

***

### Price vs. Carat and Clarity
图形的颜色设置、图例设置、图名设置等

Adjust the code below to color the points by clarity.

A layer called scale_color_brewer() has 
been added to adjust the legend and
provide custom colors.

You will need to install the package RColorBrewer
in R to get the same colors and color palettes.

Alter the code below.
```{r Price vs. Carat and Clarity}
# install and load the RColorBrewer package
#install.packages('RColorBrewer')
library(RColorBrewer)

ggplot(aes(x = carat, y = price, colour = clarity), data = diamonds) + 
  geom_point(alpha = 0.5, size = 1, position = 'jitter') +
  scale_color_brewer(type = 'div',
    guide = guide_legend(title = 'Clarity', reverse = T,
    override.aes = list(alpha = 1, size = 2))) +  
  scale_x_continuous(trans = cuberoot_trans(), limits = c(0.2, 3),
    breaks = c(0.2, 0.5, 1, 2, 3)) + 
  scale_y_continuous(trans = log10_trans(), limits = c(350, 15000),
    breaks = c(350, 1000, 5000, 10000, 15000)) +
  ggtitle('Price (log10) by Cube-Root of Carat and Clarity')
```

***

### Clarity and Price
Response:
显然同一重量下，不同纯净度的钻石价格有差异，纯净度越高越贵。

***

### Price vs. Carat and Cut

Alter the code below.
```{r Price vs. Carat and Cut}
ggplot(aes(x = carat, y = price, color = cut), data = diamonds) + 
  geom_point(alpha = 0.5, size = 1, position = 'jitter') +
  scale_color_brewer(type = 'div',
                     guide = guide_legend(title = 'Cut', reverse = T,
                                          override.aes = list(alpha = 1, size = 2))) +  
  scale_x_continuous(trans = cuberoot_trans(), limits = c(0.2, 3),
                     breaks = c(0.2, 0.5, 1, 2, 3)) + 
  scale_y_continuous(trans = log10_trans(), limits = c(350, 15000),
                     breaks = c(350, 1000, 5000, 10000, 15000)) +
  ggtitle('Price (log10) by Cube-Root of Carat and Cut')
```

***

### Cut and Price
Response:
有影响，但不太明显。大部分切割都是完美，其余的很少。

***

### Price vs. Carat and Color

Alter the code below.
```{r Price vs. Carat and Color}
ggplot(aes(x = carat, y = price, color = color), data = diamonds) + 
  geom_point(alpha = 0.5, size = 1, position = 'jitter') +
  scale_color_brewer(type = 'div',
                     guide = guide_legend(title = 'Color',
                                          override.aes = list(alpha = 1, size = 2))) +  
  scale_x_continuous(trans = cuberoot_trans(), limits = c(0.2, 3),
                     breaks = c(0.2, 0.5, 1, 2, 3)) + 
  scale_y_continuous(trans = log10_trans(), limits = c(350, 15000),
                     breaks = c(350, 1000, 5000, 10000, 15000)) +
  ggtitle('Price (log10) by Cube-Root of Carat and Color')
```

***

### Color and Price
Response:
显然有影响。
***

### Linear Models in R
Notes:
线性模型
用lm()函数
遵循lm(y~x)形式，从结果变量到解释变量

Response:

***

### Building the Linear Model
Notes:
注意m1模型中，用到了I(wrapper)，作用是“保持这样”，是用I内部函数进行转换后，再进行递归。
这样做的好处是替代了R来进行解释，作为一个算法的部分参与设计矩阵，以构成回归。

更多的线性模型描述：http://data.princeton.edu/R/linearModels.html

运用这样的方法，可以逐步构建模型，比如增加重量，构成m2
再增加cut，构成m3
再增加color，构成m4
再增加clarity，构成m5
最后，用mtable()来比较模型评估结果

至此，线性模型的基本框架可以修改如下：
lmfit = lm( change ~ setting + effort )

```{r Building the Linear Model}
m1 <- lm(I(log(price)) ~ I(carat^(1/3)), data = diamonds)
m2 <- update(m1, ~ . + carat)
m3 <- update(m2, ~ . + cut)
m4 <- update(m3, ~ . + color)
m5 <- update(m4, ~ . + clarity)
mtable(m1, m2, m3, m4, m5)
```

Notice how adding cut to our model does not help explain much of the variance
in the price of diamonds. This fits with out exploration earlier.

***

### Model Problems
Video Notes:



Research:
(Take some time to come up with 2-4 problems for the model)
(You should 10-20 min on this)

Response:

价格不是单纯由产品品质决定的。更多受到环境因素影响。

answer
- 通胀因素
- 市场影响
- 中国市场升温
- 不同克拉的钻石不均衡增长

***

### A Bigger, Better Data Set
Notes:

```{r A Bigger, Better Data Set}
#install.package('bitops')
#install.packages('RCurl')
library('bitops')
library('RCurl')

#diamondsurl = getBinaryURL("https://raw.github.com/solomonm/diamonds-data/master/BigDiamonds.Rda")
#load(rawConnection(diamondsurl))
```





The code used to obtain the data is available here:
https://github.com/solomonm/diamonds-data

## Building a Model Using the Big Diamonds Data Set
Notes:

Your task is to build five linear models like Solomon
did for the diamonds data set only this
time you'll use a sample of diamonds from the
diamondsbig data set.

Be sure to make use of the same variables
(logprice, carat, etc.) and model
names (m1, m2, m3, m4, m5).

To get the diamondsbig data into RStudio
on your machine, copy, paste, and run the
code in the Instructor Notes. There's
598,024 diamonds in this data set!

Since the data set is so large,
you are going to use a sample of the
data set to compute the models. You can use
the entire data set on your machine which
will produce slightly different coefficients
and statistics for the models.

注意用采样

You can leave off the code to load in the data.
We've sampled the data for you.
You also don't need code to create the table output of the models.
We'll do that for you and check your model summaries (R^2 values, AIC, etc.)

Your task is to write the code to create the models.
```{r Building a Model Using the Big Diamonds Data Set}
load("BigDiamonds.rda")

#diamondsBigSample <- read.csv('diamondsBigSample.csv')

m1 <- lm(I(log(price)) ~ I(carat^(1/3)), data = diamondsbig)
m2 <- update(m1, ~ . + carat)
m3 <- update(m2, ~ . + cut)
m4 <- update(m3, ~ . + color)
m5 <- update(m4, ~ . + clarity)

suppressMessages(library(lattice))
suppressMessages(library(MASS))
suppressMessages(library(memisc))
models <- mtable(m1, m2, m3, m4, m5)
models
```

```{r answer}
diamondsbig$logprice = log(diamondsbig$price)

m1 <- lm(logprice ~ I(carat^(1/3)), data = diamondsbig[diamondsbig$price < 10000 &
                                                         diamondsbig$cert == 'GIA',])
m2 <- update(m1, ~ . + carat)
m3 <- update(m2, ~ . + cut)
m4 <- update(m3, ~ . + color)
m5 <- update(m4, ~ . + clarity)

suppressMessages(library(lattice))
suppressMessages(library(MASS))
suppressMessages(library(memisc))
models <- mtable(m1, m2, m3, m4, m5)
models
```

***

## Predictions

Example Diamond from BlueNile:
Round 1.00 Very Good I VS1 $5,601

```{r}
#Be sure you’ve loaded the library memisc and have m5 saved as an object in your workspace.
thisDiamond = data.frame(carat = 1.00, cut = "V.Good",
                         color = "I", clarity="VS1")
modelEstimate = predict(m5, newdata = thisDiamond,
                        interval="prediction", level = .95)
```

Evaluate how well the model predicts the BlueNile diamond's price. Think about the fitted point estimate as well as the 95% CI.



此处的预测区间可能稍微有些保守，因为模型误差是克拉（并因此是价格）的异方差，即使在进行对数和立方根转换之后。

请见以下代码的输出。 
``` {r}
dat = data.frame(m4$model, m4$residuals) 

with(dat, sd(m4.residuals)) 

with(subset(dat, carat > .9 & carat < 1.1), sd(m4.residuals)) 

dat$resid <- as.numeric(dat$m4.residuals)
ggplot(aes(y = resid, x = round(carat, 2)), data = dat) + 
  geom_line(stat = "summary", fun.y = sd) 
```
怎样可以做得更好？如果我们关注的是 0.5 到 1.5 克拉的钻石，我们可以只用这部分的数据来拟合模型——别担心，数据量是足够的。
***

## Final Thoughts
Notes:

***

Click **KnitHTML** to see all of your hard work and to have an html
page of this lesson, your answers, and your notes!

